// Class: ReadRuleFit
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : RuleFit::RuleFit
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.22/06       [398854]
Creator        : apetkovic
Date           : Sun Jan 10 16:55:31 2021
Host           : Linux buildvm-x86-05.iad2.fedoraproject.org 5.7.11-200.fc32.x86_64 #1 SMP Wed Jul 29 17:15:52 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/apetkovic/Vjezbe/Vjezbe_12
Training events: 2000
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "True" [Print method-specific help message]
GDTau: "-1.000000e+00" [Gradient-directed (GD) path: default fit cut-off]
GDTauPrec: "1.000000e-02" [GD path: precision of tau]
GDStep: "1.000000e-02" [GD path: step size]
GDNSteps: "10000" [GD path: number of steps]
GDErrScale: "1.020000e+00" [Stop scan when error > scale*errmin]
fEventsMin: "1.000000e-02" [Minimum fraction of events in a splittable node]
fEventsMax: "5.000000e-01" [Maximum fraction of events in a splittable node]
nTrees: "20" [Number of trees in forest.]
RuleMinDist: "1.000000e-03" [Minimum distance between rules]
MinImp: "1.000000e-03" [Minimum rule importance accepted]
Model: "modrulelinear" [Model to be used]
RuleFitModule: "rftmva" [Which RuleFit module to use]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
LinQuantile: "2.500000e-02" [Quantile of linear terms (removes outliers)]
GDPathEveFrac: "5.000000e-01" [Fraction of events used for the path search]
GDValidEveFrac: "5.000000e-01" [Fraction of events used for the validation]
ForestType: "adaboost" [Method to use for forest generation (AdaBoost or RandomForest)]
RFWorkDir: "./rulefit" [Friedman's RuleFit module (RFF): working dir]
RFNrules: "2000" [RFF: Mximum number of rules]
RFNendnodes: "4" [RFF: Average number of end nodes]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
ele_pt                        ele_pt                        ele_pt                        ele_pt                                                          'F'    [5.00599241257,306.198883057]
ele_ep                        ele_ep                        ele_ep                        ele_ep                                                          'F'    [0.000418868934503,20]
ele_fbrem                     ele_fbrem                     ele_fbrem                     ele_fbrem                                                       'F'    [-1,0.991997241974]
ele_eelepout                  ele_eelepout                  ele_eelepout                  ele_eelepout                                                    'F'    [0.0226789675653,20]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadRuleFit : public IClassifierReader {

 public:

   // constructor
   ReadRuleFit( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadRuleFit" ),
        fNvars( 4 )
   {
      // the training input variables
      const char* inputVars[] = { "ele_pt", "ele_ep", "ele_fbrem", "ele_eelepout" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadRuleFit() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   // not implemented for class: "ReadRuleFit"
};
void   ReadRuleFit::Initialize(){}
void   ReadRuleFit::Clear(){}
double ReadRuleFit::GetMvaValue__( const std::vector<double>& inputValues ) const {
   double rval=0.9862926232;
   //
   // here follows all rules ordered in importance (most important first)
   // at the end of each line, the relative importance of the rule is given
   //
   if ((inputValues[1]<1.905140877)&&(inputValues[3]<0.97397995)) rval+=-0.958981623;   // importance = 1.000
   if ((inputValues[0]<19.34851074)) rval+=-0.5470643055;   // importance = 0.617
   if ((0.9249407053<inputValues[1])&&(inputValues[1]<1.905140877)&&(inputValues[3]<0.97397995)) rval+=0.6452961761;   // importance = 0.522
   if ((inputValues[0]<13.37410927)&&(1.08560276<inputValues[1])&&(inputValues[1]<2.857501984)) rval+=-0.6315096547;   // importance = 0.492
   if ((7.735370636<inputValues[0])) rval+=0.5368633697;   // importance = 0.488
   if ((16.88737106<inputValues[0])&&(0.97397995<inputValues[3])) rval+=0.4181851803;   // importance = 0.470
   if ((inputValues[0]<19.34851074)&&(inputValues[2]<0.4205900729)) rval+=-0.4413896957;   // importance = 0.457
   if ((13.37410927<inputValues[0])&&(1.08560276<inputValues[1])&&(inputValues[1]<2.857501984)) rval+=-0.462892212;   // importance = 0.453
   if ((1.925280929<inputValues[3])) rval+=-0.4456271918;   // importance = 0.433
   if ((18.22512817<inputValues[0])&&(0.3279981613<inputValues[2])) rval+=0.2996520883;   // importance = 0.318
   if ((20.08688354<inputValues[0])&&(inputValues[0]<27.84599686)) rval+=-0.4298326318;   // importance = 0.313
   if ((2.857501984<inputValues[1])) rval+=-0.3987941298;   // importance = 0.290
   if ((1.826363206<inputValues[3])&&(inputValues[3]<2.66735816)) rval+=-0.398634233;   // importance = 0.256
   if ((inputValues[3]<1.88060236)) rval+=-0.2552139487;   // importance = 0.250
   if ((0.6125692129<inputValues[2])) rval+=-0.2268722456;   // importance = 0.241
   if ((0.9972832799<inputValues[1])&&(inputValues[1]<2.857501984)) rval+=0.2077131097;   // importance = 0.235
   if ((19.34851074<inputValues[0])&&(inputValues[1]<4.762223721)&&(inputValues[2]<0.8971402049)) rval+=-0.2001648051;   // importance = 0.225
   if ((1.905140877<inputValues[1])&&(inputValues[3]<0.97397995)) rval+=-0.3447046079;   // importance = 0.217
   if ((inputValues[0]<33.70154953)&&(inputValues[1]<0.9527798891)&&(0.1364720613<inputValues[2])) rval+=-0.2930634707;   // importance = 0.203
   if ((inputValues[1]<4.762223721)&&(0.8971402049<inputValues[2])) rval+=-0.3348825382;   // importance = 0.193
   if ((0.1382841319<inputValues[2])&&(inputValues[3]<0.97397995)) rval+=0.2306602751;   // importance = 0.192
   if ((1.905140877<inputValues[1])&&(inputValues[2]<0.1382841319)) rval+=-0.2950182991;   // importance = 0.179
   if ((0.1382841319<inputValues[2])&&(0.97397995<inputValues[3])) rval+=-0.1486468547;   // importance = 0.168
   if ((19.34851074<inputValues[0])&&(inputValues[2]<0.4205900729)) rval+=-0.1687332151;   // importance = 0.168
   if ((1.119942904<inputValues[1])&&(inputValues[1]<1.905140877)&&(inputValues[2]<0.1382841319)) rval+=-0.2503098049;   // importance = 0.159
   if ((inputValues[1]<1.374372125)&&(0.6125692129<inputValues[2])&&(inputValues[2]<0.7398882508)) rval+=0.2570047705;   // importance = 0.145
   if ((1.058408499<inputValues[1])&&(0.1013799459<inputValues[2])&&(inputValues[2]<0.5445167422)) rval+=0.129970555;   // importance = 0.113
   if ((inputValues[2]<0.2331411541)&&(inputValues[3]<1.925280929)) rval+=-0.09767708679;   // importance = 0.109
   if ((inputValues[0]<31.43823624)&&(inputValues[1]<1.905140877)&&(inputValues[2]<0.1382841319)) rval+=-0.1132104492;   // importance = 0.109
   if ((inputValues[0]<19.34851074)&&(0.4205900729<inputValues[2])) rval+=-0.1287068466;   // importance = 0.108
   if ((0.6125692129<inputValues[2])&&(inputValues[2]<0.7398882508)) rval+=-0.1437016191;   // importance = 0.100
   if ((inputValues[1]<4.762223721)&&(inputValues[2]<0.8971402049)) rval+=-0.1315669022;   // importance = 0.100
   if ((inputValues[0]<33.72386551)&&(1.905140877<inputValues[1])&&(inputValues[2]<0.1382841319)) rval+=-0.1851401651;   // importance = 0.097
   if ((inputValues[0]<19.34851074)&&(inputValues[1]<4.762223721)&&(inputValues[2]<0.8971402049)&&(inputValues[3]<2.918486595)) rval+=0.08217110917;   // importance = 0.091
   if ((inputValues[0]<33.69102859)&&(inputValues[2]<0.2306807041)&&(inputValues[3]<2.002154827)) rval+=0.08385202247;   // importance = 0.089
   if ((inputValues[0]<33.69102859)&&(inputValues[2]<0.2306807041)&&(2.002154827<inputValues[3])) rval+=-0.2945456331;   // importance = 0.084
   if ((inputValues[2]<0.7076679468)) rval+=-0.07226288098;   // importance = 0.071
   if ((33.69102859<inputValues[0])&&(inputValues[2]<0.04342712834)&&(0.9818148613<inputValues[3])) rval+=-0.2405105768;   // importance = 0.068
   if ((inputValues[0]<16.88737106)&&(0.97397995<inputValues[3])) rval+=0.07590532408;   // importance = 0.064
   if ((inputValues[2]<0.6125692129)&&(1.204468489<inputValues[3])) rval+=0.0580296131;   // importance = 0.056
   if ((31.15504837<inputValues[0])&&(1.119942904<inputValues[1])&&(inputValues[1]<1.905140877)&&(inputValues[2]<0.1382841319)) rval+=-0.1683927027;   // importance = 0.049
   if ((33.70154953<inputValues[0])&&(inputValues[1]<0.9527798891)&&(0.1364720613<inputValues[2])) rval+=-0.07200509935;   // importance = 0.034
   if ((inputValues[0]<19.34851074)&&(inputValues[1]<4.762223721)&&(inputValues[2]<0.8971402049)&&(2.918486595<inputValues[3])) rval+=-0.07346730699;   // importance = 0.025
   if ((1.058408499<inputValues[1])&&(0.151832208<inputValues[2])&&(inputValues[2]<0.6125692129)&&(inputValues[3]<0.997697711)) rval+=-0.05146966999;   // importance = 0.024
   if ((inputValues[1]<2.857501984)) rval+=-0.03174362272;   // importance = 0.023
   if ((1.058408499<inputValues[1])&&(0.151832208<inputValues[2])&&(inputValues[2]<0.6125692129)&&(0.997697711<inputValues[3])) rval+=-0.02254288034;   // importance = 0.017
   if ((30.08815384<inputValues[0])&&(0.1382841319<inputValues[2])&&(inputValues[3]<0.97397995)) rval+=0.01975117057;   // importance = 0.009
   if ((0.6125692129<inputValues[2])&&(0.5123332143<inputValues[3])&&(inputValues[3]<1.826363206)) rval+=0.007903898613;   // importance = 0.006
   if ((inputValues[0]<30.08815384)&&(0.1382841319<inputValues[2])&&(inputValues[3]<0.97397995)) rval+=-0.001798098579;   // importance = 0.001
   //
   // here follows all linear terms
   // at the end of each line, the relative importance of the term is given
   //
   rval+=0.01128557021*std::min( double(79.21653748), std::max( double(inputValues[0]), double(5.206739902)));   // importance = 0.461
   rval+=-0.1874771805*std::min( double(7.943171501), std::max( double(inputValues[1]), double(0.338311702)));   // importance = 0.630
   rval+=-0.004933515436*std::min( double(0.9429931045), std::max( double(inputValues[2]), double(-0.1237429529)));   // importance = 0.004
   rval+=-0.01410735547*std::min( double(13.42124367), std::max( double(inputValues[3]), double(0.1592582166)));   // importance = 0.080
   return rval;
}
inline double ReadRuleFit::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}
